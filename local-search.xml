<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Speech领域专业名词（持续更新）</title>
    <link href="/2020/06/30/001_speech_note/"/>
    <url>/2020/06/30/001_speech_note/</url>
    
    <content type="html"><![CDATA[<h3 id="频率-Frequency-amp-幅度-Magnitude-amp-相位-Phase"><a href="#频率-Frequency-amp-幅度-Magnitude-amp-相位-Phase" class="headerlink" title="频率 Frequency &amp; 幅度 Magnitude &amp; 相位 Phase"></a>频率 Frequency &amp; 幅度 Magnitude &amp; 相位 Phase</h3><h3 id="音高-Pitch-amp-音量-Loudness-amp-音色-Timbre"><a href="#音高-Pitch-amp-音量-Loudness-amp-音色-Timbre" class="headerlink" title="音高 Pitch &amp; 音量 Loudness &amp; 音色 Timbre"></a>音高 Pitch &amp; 音量 Loudness &amp; 音色 Timbre</h3><h3 id="分贝-dB"><a href="#分贝-dB" class="headerlink" title="分贝 dB"></a>分贝 dB</h3><h3 id="模数转换-Analog-to-Digital-Conversion，ADC"><a href="#模数转换-Analog-to-Digital-Conversion，ADC" class="headerlink" title="模数转换 Analog to Digital Conversion，ADC"></a>模数转换 Analog to Digital Conversion，ADC</h3><h3 id="音素-Phoneme"><a href="#音素-Phoneme" class="headerlink" title="音素 Phoneme"></a>音素 Phoneme</h3><p>描述一种语言的基本单位被称为音素Phoneme，例如BRYAN这个词就可以看做是由B, R, AY, AX, N五个音素构成的。英语中大概有50多个音素，可以用50几个HMM state来表示这些音素。</p><h3 id="掩蔽效应-Masking-Effects"><a href="#掩蔽效应-Masking-Effects" class="headerlink" title="掩蔽效应 Masking Effects"></a>掩蔽效应 Masking Effects</h3><h3 id="频谱图-Spectrogram"><a href="#频谱图-Spectrogram" class="headerlink" title="频谱图 Spectrogram"></a>频谱图 Spectrogram</h3><h3 id="声学模型-Acoustic-model"><a href="#声学模型-Acoustic-model" class="headerlink" title="声学模型 Acoustic model"></a>声学模型 Acoustic model</h3><p>语音中很多发音都是连在一起的，很难区分，所以一般用左中右三个HMM state来描述一个音素。举例来说BRYAN这个词中的R音素就变成了用B-R, R, R-AY三个HMM state来表示。这样BRYAN这个词根据上下文就需要15个state了，根据所有单词的上下文总共大概需要几千个HMM state，这种方式属于context dependent模型中的三音素triphone模式。这个HMM state的个数在各家语音识别系统中都不一样，是一个需要调的参数。所以声学模型就是如何设置HMM state。</p><h3 id="语音模型-Language-Model-LM"><a href="#语音模型-Language-Model-LM" class="headerlink" title="语音模型 Language Model, LM"></a>语音模型 Language Model, LM</h3><h3 id="Lexicon"><a href="#Lexicon" class="headerlink" title="Lexicon"></a>Lexicon</h3><h3 id="帧-Frame"><a href="#帧-Frame" class="headerlink" title="帧 Frame"></a>帧 Frame</h3><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><h3 id="隐马尔可夫模型-Hidden-Markov-Model-HMM"><a href="#隐马尔可夫模型-Hidden-Markov-Model-HMM" class="headerlink" title="隐马尔可夫模型 Hidden Markov Model, HMM"></a>隐马尔可夫模型 Hidden Markov Model, HMM</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://mp.weixin.qq.com/s/_jK4eTdboU9A-E785FUBJg" target="_blank" rel="noopener">CSLT微信公众号-语音识别基础：（一）语音是什么</a></p><p>[2] <a href="https://mp.weixin.qq.com/s/XRTCCcEdmQTk4XitVo8U2Q" target="_blank" rel="noopener">CSLT微信公众号-语音识别基础：（二）语音识别方法</a></p><p>[3] <a href="https://mp.weixin.qq.com/s/e4bO-koOmIrAfqC-zwOvwg" target="_blank" rel="noopener">语音识别基础：（三）完整的语音识别实验</a></p>]]></content>
    
    
    <categories>
      
      <category>Speech</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>语音</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美化 Python 异常信息</title>
    <link href="/2020/06/17/200617_pyerrors/"/>
    <url>/2020/06/17/200617_pyerrors/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Github链接<a href="https://github.com/onelivesleft/PrettyErrors" target="_blank" rel="noopener">PrettyErrors</a></p><pre><code class="hljs bash">python -m pip install pretty_errorspython -m pretty_errors</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/100234650" target="_blank" rel="noopener">知乎-一行代码简化Python异常信息</a></p>]]></content>
    
    
    <categories>
      
      <category>toolkit</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>工具</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2020/06/17/200621_computer_network/"/>
    <url>/2020/06/17/200621_computer_network/</url>
    
    <content type="html"><![CDATA[<h2 id="工作装备"><a href="#工作装备" class="headerlink" title="工作装备"></a>工作装备</h2><ol><li>物理层：中继器，集线器</li><li>数据链路：网桥，交换机</li><li>网络层：路由器 </li><li>传输层： 网关</li></ol><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><ol><li>物理层： RJ45 、 CLOCK 、 IEEE802.3</li><li>数据链路： PPP 、 FR 、 HDLC 、 VLAN 、 MAC</li><li>网络层： IP 、 ICMP 、 ARP 、 RARP 、 OSPF 、 IPX 、 RIP 、 IGRP</li><li>传输层： TCP 、 UDP 、 SPX</li><li>会话层： NFS 、 SQL 、 NETBIOS 、 RPC</li><li>表示层： JPEG 、 MPEG 、 ASII</li><li>应用层： FTP 、 DNS 、 Telnet 、 SMTP 、 HTTP 、 WWW 、 NFS</li></ol>]]></content>
    
    
    <categories>
      
      <category>offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Discriminant Analysis</title>
    <link href="/2020/06/14/200614_Linear_Discriminant_Analysis/"/>
    <url>/2020/06/14/200614_Linear_Discriminant_Analysis/</url>
    
    <content type="html"><![CDATA[<p>线性判别分析（Linear Discriminant Analysis，LDA）是一种经典的线性分类方法。LDA是一种有监督的线性分类算法。LDA的基本思想是将数据投影到低维空间后，使得：<strong>同一类数据尽可能接近，不同类数据尽可能疏远</strong>。在对新样本进行分类时，将其投影到同样的低维空间上，再根据投影点的位置来确定新样本的类别。</p><p><img src="https://wx1.sbimg.cn/2020/06/14/lda.png" srcset="/img/loading.gif" alt="avatar"></p><p>值得一提的是，LDA 可从贝时斯决策理论的角度来阐释，并可证明，当两类数据同先验、满足高斯分布且协方差相等时，LDA 可达到最优分类。</p><h2 id="Fisher-discriminant-criterion"><a href="#Fisher-discriminant-criterion" class="headerlink" title="Fisher discriminant criterion"></a>Fisher discriminant criterion</h2><ol><li>$X_i$ 表示 $i$ 类示例的集合</li><li>$N$ 表示有 $N$ 类，且第 $i$ 类的样本数为 $N_i$</li><li>$n$ 表示总共有 $n$ 个数据</li><li>$\mu_i$ 表示 $i$ 类示例的均值向量，$\mu$ 表示总的均值向量</li><li>$\Sigma_i$ 表示 $i$ 类示例的协方差矩阵</li><li>$S_w$ 表示类内散度矩阵（within-class scatter matrix）</li><li>$S_b$ 表示类间散度矩阵（between-class scatter matrix）</li><li>$S_t$ 表示全局散度矩阵</li><li>$w$ 为变换矩阵</li><li>$J(w)$ 是最大目标Fisher判别准则</li></ol><p>$$\boldsymbol{\mu_i} = \frac{1}{N_i} \sum_{\boldsymbol{x} \in X_i}\boldsymbol{x}$$</p><p>$$\Sigma_i = \sum_{\boldsymbol{x} \in X_i}(\boldsymbol{x}-\boldsymbol{\mu_i})(\boldsymbol{x}-\boldsymbol{\mu_i})^T$$</p><p>$$S_w = \sum^N_{i=1}S_{w_i} = \sum^N_{i=1}\Sigma_i = \sum^N_{i=1}\sum_{\boldsymbol{x} \in X_i}(\boldsymbol{x}-\boldsymbol{\mu_i})(\boldsymbol{x}-\boldsymbol{\mu_i})^T$$</p><p>$$S_b = S_t - S_w = \sum^N_{i=1}N_i(\boldsymbol{\mu_i}-\boldsymbol{\mu})(\boldsymbol{\mu_i}-\boldsymbol{\mu})^T$$</p><p>$$S_t = S_b + S_w =\sum_{i=1}^{n}(\boldsymbol{x_i}-\boldsymbol{\mu})(\boldsymbol{x_i}-\boldsymbol{\mu})^T$$</p><p>$$J(w) = \frac{w^TS_bw}{w^TS_ww}$$</p><p>优化目标推导过程</p><p>$$ \frac{\mathrm{d}J(w)}{\mathrm{d}w} = 0 $$</p><p>$$<br>\frac{\mathrm{d}J(w)}{\mathrm{d}w} = \frac{\mathrm{d}}{\mathrm{d}w}(\frac{w^TS_bw}{w^TS_ww}) =<br>$$</p><p><img src="https://wx2.sbimg.cn/2020/06/14/lda_s.png" srcset="/img/loading.gif" alt="avatar"></p><p>多分类 LDA 可以有多种实现方法：使用 $S_b$, $S_w$ , $S_t$ 三者中的任何两个即可</p><h2 id="LDA-算法的训练流程"><a href="#LDA-算法的训练流程" class="headerlink" title="LDA 算法的训练流程"></a>LDA 算法的训练流程</h2><ol><li>计算类内散度矩阵 $S_w$</li><li>计算类间散度矩阵 $S_b$</li><li>计算矩阵 $S_w^{-1}S_b$</li><li>计算矩阵 $S_w^{-1}S_b$ 的特征值与特征向量，按从小到大的顺序选取前 $d$ 个特征值和对应的 $d$ 个特征向量，得到投影矩阵 $w$</li></ol><h2 id="sklearn包-LDA-的使用"><a href="#sklearn包-LDA-的使用" class="headerlink" title="sklearn包 LDA 的使用"></a>sklearn包 LDA 的使用</h2><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sklearn.discriminant_analysis <span class="hljs-keyword">import</span> LinearDiscriminantAnalysis <span class="hljs-keyword">as</span> LDAlda = LDA(solver=<span class="hljs-string">'svd'</span>, n_components=LDA_components)<span class="hljs-comment"># fit</span>lda.fit(train_data, train_label)<span class="hljs-comment"># transform</span>train_data = lda.transform(train_data)test_data = lda.transform(test_data)</code></pre><h2 id="LDA-Python-代码实现"><a href="#LDA-Python-代码实现" class="headerlink" title="LDA Python 代码实现"></a>LDA Python 代码实现</h2><h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://wangd.cslt.org/teach/speech-processing/3.2-SA-LDA.ppt" target="_blank" rel="noopener">CSLT-THU王东老师PPT-Static Analysis: LDA</a></p><p>[2] <a href="">西瓜书-线性判别分析</a></p><p>[3] <a href="http://166.111.134.19:7777/mlbook/" target="_blank" rel="noopener">CSLT-THU王东老师-现代机器学习导论</a></p><p>[4] <a href="https://mp.weixin.qq.com/s/PZpEtcdiPUxIv6M3sGOaGA" target="_blank" rel="noopener">机器学习实验室微信公众号-数学推导LDA线性判别分析</a></p><p>[5] <a href="https://www.cnblogs.com/timlong/p/11403709.html" target="_blank" rel="noopener">博客园-LDA</a></p><p>[6] <a href="https://zhuanlan.zhihu.com/p/79696530" target="_blank" rel="noopener">知乎-线性判别分析LDA原理及推导过程（非常详细）</a></p><p>[7] <a href="https://www.bilibili.com/video/BV15t411v7Pg?p=7" target="_blank" rel="noopener">THU袁博老师数据挖掘课程-数据预处理PPT</a></p><p>[8] <a href="https://zhuanlan.zhihu.com/p/33742983" target="_blank" rel="noopener">知乎-Fisher判别分析(Fisher Discriminant Analysis)</a></p>]]></content>
    
    
    <categories>
      
      <category>backends</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flow 模型</title>
    <link href="/2020/06/12/002_flow/"/>
    <url>/2020/06/12/002_flow/</url>
    
    <content type="html"><![CDATA[<h2 id="基础数学"><a href="#基础数学" class="headerlink" title="基础数学"></a>基础数学</h2><h3 id="生成模型要解决的问题"><a href="#生成模型要解决的问题" class="headerlink" title="生成模型要解决的问题"></a>生成模型要解决的问题</h3><p>给定两组数据 $z$ 和 $x$ ，其中 $z$ 服从已知的简单先验分布 $\pi(z)$ ，通常是高斯分布，$x$ 服从复杂的分布 $p(x)$ ,即训练数据代表的分布，现在我们想要找到一个变换函数 $f$ ，它能建立一种 $z$ 到 $x$ 的映射，使得每对于 $\pi(z)$ 中的一个采样点，都能在 $p(x)$ 中有一个（新）样本点与之对应。</p><p>$$ p_g(x) = \int_z p(x|z)p(z)dz\ $$</p><p>其中，$ p(x|z) $ - $ the \  probability \  of \  x \  given \  z$</p><h3 id="概率分布的变换数学例题"><a href="#概率分布的变换数学例题" class="headerlink" title="概率分布的变换数学例题"></a>概率分布的变换数学例题</h3><h3 id="Jacobian-Matrix"><a href="#Jacobian-Matrix" class="headerlink" title="Jacobian Matrix"></a>Jacobian Matrix</h3><p>$$<br>\left[<br>    \begin{array}{ccc}<br>        \frac{\partial f_1 }{\partial x_1 } &amp; \cdots &amp; \frac{\partial f_1 }{\partial x_n } \\<br>        \vdots\quad &amp; \ddots &amp; \vdots\quad \\<br>        \frac{\partial f_n }{\partial x_1 } &amp; \cdots &amp; \frac{\partial f_n }{\partial x_n } \\<br>    \end{array}<br>\right]<br>$$</p><p>$$J_{ij}=\frac{\partial f_i }{\partial x_j }$$</p><h3 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h3><h2 id="耦合层（Coupling-Layer）"><a href="#耦合层（Coupling-Layer）" class="headerlink" title="耦合层（Coupling Layer）"></a>耦合层（Coupling Layer）</h2><h2 id="NICE"><a href="#NICE" class="headerlink" title="NICE"></a>NICE</h2><h2 id="RealNVP"><a href="#RealNVP" class="headerlink" title="RealNVP"></a>RealNVP</h2><h2 id="MAF"><a href="#MAF" class="headerlink" title="MAF"></a>MAF</h2><h2 id="Glow"><a href="#Glow" class="headerlink" title="Glow"></a>Glow</h2><h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <categories>
      
      <category>flows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>笔记</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNF 模型的Pytorch实现</title>
    <link href="/2020/06/12/005_DNF_implement/"/>
    <url>/2020/06/12/005_DNF_implement/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>flows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>笔记</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flow 模型的Pytorch实现</title>
    <link href="/2020/06/12/004_flow_implement/"/>
    <url>/2020/06/12/004_flow_implement/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>flows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>笔记</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNF 模型</title>
    <link href="/2020/06/12/003_DNF/"/>
    <url>/2020/06/12/003_DNF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>flows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>笔记</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多个 PDF 文件的快速合并</title>
    <link href="/2020/06/10/200610_pdf_merge/"/>
    <url>/2020/06/10/200610_pdf_merge/</url>
    
    <content type="html"><![CDATA[<p>毕设论文需要合并多个pdf文件，记录一下pdf文件的合并过程</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs bash">sudo apt-get install poppler-utils</code></pre><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><pre><code class="hljs bash"><span class="hljs-comment"># 全部</span>pdfunite *.pdf all.pdf<span class="hljs-comment"># 顺序</span>pdfunite 1.pdf 2.pdf 3.pdf 4.pdf all-1234.pdf</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/a912952381/article/details/80682669" target="_blank" rel="noopener">linux bash合并PDF文件</a></p>]]></content>
    
    
    <categories>
      
      <category>toolkit</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>工具</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Softmax &amp; Cross-Entropy &amp; KLD</title>
    <link href="/2020/06/09/200609_softmax/"/>
    <url>/2020/06/09/200609_softmax/</url>
    
    <content type="html"><![CDATA[<h2 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h2><p>$ Softmax $ 的作用是把一个序列$\boldsymbol{a}$，变成概率。</p><p>$$ Softmax(\boldsymbol{a}) = \frac{e^{a_i}}{\sum_j e^{a_j}} $$</p><p>从概率的角度解释 $Softmax$ 的话，就是 $S_i = \frac{e^{a_i}}{\sum_{k=1}^Ne^{a_k}} = P(y=i|a)$</p><p>其中，$LR$ 是 $Softmax$ 的类别数为 2 时 $Softmax$ 的特殊形式</p><h2 id="Cross-Entropy"><a href="#Cross-Entropy" class="headerlink" title="Cross-Entropy"></a>Cross-Entropy</h2><p>给定两个概率分布： $p$ （理想结果即正确标签向量）和 $q$ （神经网络输出结果即经过 $softmax$ 转换后的结果向量），则通过 $q$ 来表示 $p$ 的交叉熵为</p><p>$$ H(p, q) = -\sum_x p(x)log(q(x)) $$</p><p>例如</p><p>$$H(p=[1,0,0], q=[0.5,0.4,0.1])  = -(1 \cdot log(0.5) + 0 \cdot log(0.4) + 0 \cdot log(0.1)) $$</p><h2 id="nll-loss-negative-log-likelihood-loss"><a href="#nll-loss-negative-log-likelihood-loss" class="headerlink" title="nll_loss (negative log likelihood loss)"></a>nll_loss (negative log likelihood loss)</h2>]]></content>
    
    
    <categories>
      
      <category>概率论与线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch Data Loader</title>
    <link href="/2020/06/09/200609_pytorch_data_loader/"/>
    <url>/2020/06/09/200609_pytorch_data_loader/</url>
    
    <content type="html"><![CDATA[<p><code>DotaLoader</code>的构建</p><pre><code class="hljs Python">DataLoader(dataset, batch_size=<span class="hljs-number">200</span>, shuffle=<span class="hljs-literal">False</span>, sampler=<span class="hljs-literal">None</span>,           batch_sampler=<span class="hljs-literal">None</span>, num_workers=<span class="hljs-number">0</span>, collate_fn=<span class="hljs-literal">None</span>,           pin_memory=<span class="hljs-literal">False</span>, drop_last=<span class="hljs-literal">False</span>, timeout=<span class="hljs-number">0</span>,           worker_init_fn=<span class="hljs-literal">None</span>)</code></pre><h2 id="官方模板"><a href="#官方模板" class="headerlink" title="官方模板"></a>官方模板</h2><p>PyTorch官方为我们提供了自定义数据读取的标准化代码代码模块。</p><pre><code class="hljs Python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomDataset</span><span class="hljs-params">(Dataset)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, ...)</span>:</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, index)</span>:</span>        <span class="hljs-keyword">return</span> (img, label)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment"># return examples size</span>        <span class="hljs-keyword">return</span> count</code></pre><ol><li><code>__init__()</code>函数用于初始化数据读取逻辑，比如读取包含标签和图片地址的csv文件、定义transform组合等。</li><li><code>__getitem__()</code>函数用来返回数据和标签。目的上是为了能够被后续的dataloader所调用。</li><li><code>__len__()</code>函数则用于返回样本数量。</li></ol><p>其中，<code>__getitem__()</code> 和<code>__len__()</code>用于构建Map-style datasets；<code>__iter__()</code>用于构建Iterable-style datasets（一般不太用）</p><h2 id="训练集和验证集的划分"><a href="#训练集和验证集的划分" class="headerlink" title="训练集和验证集的划分"></a>训练集和验证集的划分</h2><p>如果需要对数据划分训练集和验证集，torch的Dataset对象也提供了<code>random_split</code>函数作为数据划分工具，且划分结果可直接供后续的DataLoader使用。</p><pre><code class="hljs Python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> random_splittrainset, valset = random_split(dataset, [len_dataset*<span class="hljs-number">0.7</span>, len_dataset*<span class="hljs-number">0.3</span>])</code></pre><h2 id="Mnist-Data-Loader-实现"><a href="#Mnist-Data-Loader-实现" class="headerlink" title="Mnist Data Loader 实现"></a>Mnist Data Loader 实现</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://pytorch.org/docs/stable/data.html" target="_blank" rel="noopener">官方文档 torch.utils.data</a></p><p>[2] <a href="https://mp.weixin.qq.com/s/5fXsPCpI_eYeEC12CbF17g" target="_blank" rel="noopener">夕小瑶的卖萌屋-PyTorch数据Pipeline标准化代码模板</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论复习</title>
    <link href="/2020/06/08/200608_bayes/"/>
    <url>/2020/06/08/200608_bayes/</url>
    
    <content type="html"><![CDATA[<h2 id="加法公式"><a href="#加法公式" class="headerlink" title="加法公式"></a>加法公式</h2><p>$$ P(A \cup B) = P(A) + P(B) - P(A\cap B) $$</p><h2 id="乘法公式"><a href="#乘法公式" class="headerlink" title="乘法公式"></a>乘法公式</h2><p>$$ P(AB) = P(A)P(B|A) $$</p><h2 id="协方差矩阵-与-散度矩阵"><a href="#协方差矩阵-与-散度矩阵" class="headerlink" title="协方差矩阵 与 散度矩阵"></a>协方差矩阵 与 散度矩阵</h2><p>将协方差矩阵乘以系数 $n-1$ 就得到了散度矩阵，矩阵的大小由特征维数 $d$ 决定，是一个为 $d×d$ 的半正定矩阵</p><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>贝叶斯公式用于描述两个<strong>条件概率</strong>之间的关系，比如 $P(A|B)$ 和 $P(B|A)$。</p><p>$$ P(A|B) = P(A) \frac{P(B|A)}{P(B)} $$</p><ol><li>$P(A|B)$ ：后验概率</li><li>$P(A)$：先验概率</li></ol><p>$$ P(A_i|B) = \frac{P(A_i)P(B|A_i)}{\sum^n_{j=1} P(A_j)P(B|A_j)} $$</p><h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2><p>$$ P(B) = \sum^n_{i=1} P(A_i)P(B|A_i) $$</p><p>事件 $B$ 总伴随着某个 $A_i$ 出现</p><h2 id="贝叶斯公式与全概率公式之间的关系"><a href="#贝叶斯公式与全概率公式之间的关系" class="headerlink" title="贝叶斯公式与全概率公式之间的关系"></a>贝叶斯公式与全概率公式之间的关系</h2><p>$P(A_i|B)$ 后验概率（新信息 $B$ 出现后 $A$ 发生的概率） = $P(A)$ 先验概率（ $A$ 发生的概率） $ｘ$ 可能性函数（新信息带出现来的调整）</p><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>条件概率是指事件 $A$ 在另外一个事件 $B$ 已经发生条件下的发生概率。条件概率表示为：$P(A|B)$，读作“在B的条件下A的概率”或是the probability of x given z</p><h2 id="边缘概率"><a href="#边缘概率" class="headerlink" title="边缘概率"></a>边缘概率</h2><h2 id="贝叶斯估计和极大似然估计"><a href="#贝叶斯估计和极大似然估计" class="headerlink" title="贝叶斯估计和极大似然估计"></a>贝叶斯估计和极大似然估计</h2><ol><li>MLE, Maxium Likelihood Estimator：极大似然估计</li><li>MAP, Maxium a Posterior：最大后验概率</li></ol><p>最大似然估计和贝叶斯估计最大区别便在于估计的<strong>参数</strong>不同。</p><p>最大似然估计是一种确定模型参数值的方法。确定参数值的过程，是找到能最大化模型产生真实观察数据可能性的那一组参数。要估计的参数 $θ$ 被当作是固定形式的一个未知变量，然后我们结合真实数据通过最大化似然函数来求解这个固定形式的未知变量。</p><p>贝叶斯估计则是将参数视为是有某种已知先验分布的随机变量，意思便是这个参数他不是一个固定的未知数，而是符合一定先验分布如：随机变量θ符合正态分布等！那么在贝叶斯估计中除了类条件概率密度 $p(x|w)$ 符合一定的先验分布，参数 $θ$ 也符合一定的先验分布。我们通过贝叶斯规则将参数的先验分布转化成后验分布进行求解。</p><p>在贝叶斯模型使用过程中，贝叶斯估计用的是后验概率，而最大似然估计直接使用的是类条件概率密度。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.bilibili.com/video/BV1a4411B7B4" target="_blank" rel="noopener">B站-「一个模型」教你搞定贝叶斯和全概率公式</a></p><p>[2] <a href="https://zhuanlan.zhihu.com/p/32803109" target="_blank" rel="noopener">知乎-从最大似然估计开始，你需要打下的机器学习基石</a></p><p>[3] <a href="https://www.bilibili.com/video/BV1C7411c7bs?p=1" target="_blank" rel="noopener">B站-MLE(极大似然)和MAP(最大后验)</a></p>]]></content>
    
    
    <categories>
      
      <category>概率论与线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2020/05/31/200531_segment_tree/"/>
    <url>/2020/05/31/200531_segment_tree/</url>
    
    <content type="html"><![CDATA[<h2 id="线段树的功能"><a href="#线段树的功能" class="headerlink" title="线段树的功能"></a>线段树的功能</h2><p>线段树用来处理数组的<strong>区间查询</strong>（range query）和<strong>元素更新</strong>（update）操作。可以进行<strong>区间最大值</strong>，<strong>区间最小值</strong>或者<strong>区间异或值</strong>的查询。对应于树状数组，线段树进行更新（update）的操作为<code>O(logn)</code>，进行区间查询（range query）的操作也为<code>O(logn)</code>。</p><h2 id="线段树的初始化"><a href="#线段树的初始化" class="headerlink" title="线段树的初始化"></a>线段树的初始化</h2><h2 id="更新（update）"><a href="#更新（update）" class="headerlink" title="更新（update）"></a>更新（update）</h2><h2 id="区间查询（range-query）"><a href="#区间查询（range-query）" class="headerlink" title="区间查询（range query）"></a>区间查询（range query）</h2><h2 id="完整的板子"><a href="#完整的板子" class="headerlink" title="完整的板子"></a>完整的板子</h2><h2 id="参考练习题"><a href="#参考练习题" class="headerlink" title="参考练习题"></a>参考练习题</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <categories>
      
      <category>板子</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络结构</title>
    <link href="/2020/05/31/200531_nnet/"/>
    <url>/2020/05/31/200531_nnet/</url>
    
    <content type="html"><![CDATA[<h2 id="多层感知机（MLP-Multilayer-Perceptron）"><a href="#多层感知机（MLP-Multilayer-Perceptron）" class="headerlink" title="多层感知机（MLP, Multilayer Perceptron）"></a>多层感知机（MLP, Multilayer Perceptron）</h2><p>Fully Connected Layer</p><h2 id="时延神经网络-TDNN-Time-Delay-Neural-Networks"><a href="#时延神经网络-TDNN-Time-Delay-Neural-Networks" class="headerlink" title="时延神经网络(TDNN, Time-Delay Neural Networks)"></a>时延神经网络(TDNN, Time-Delay Neural Networks)</h2><p>TDNN是一个常用于语音信号处理领域卷积神经网络，使用 FFT 预处理的语音信号作为输入，其隐含层由2个一维卷积核组成，以提取频率域上的平移不变特征。</p><h2 id="卷积神经网络（CNN-Convolutional-Neural-Networks）"><a href="#卷积神经网络（CNN-Convolutional-Neural-Networks）" class="headerlink" title="卷积神经网络（CNN, Convolutional Neural Networks）"></a>卷积神经网络（CNN, Convolutional Neural Networks）</h2><h3 id="内积-dot-product-scalar-product"><a href="#内积-dot-product-scalar-product" class="headerlink" title="内积 (dot product, scalar product)"></a>内积 (dot product, scalar product)</h3><h3 id="Architect"><a href="#Architect" class="headerlink" title="Architect"></a>Architect</h3><ol><li>Convolution</li><li>Pooling</li><li>Flatten</li></ol><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><ol><li>Some of patterns are much smaller than the whole image</li><li>The smae pattterns appear in different regions</li><li>Subsampling the pixels will not change the object</li></ol><h3 id="1-1-Convolution"><a href="#1-1-Convolution" class="headerlink" title="1 * 1 Convolution"></a>1 * 1 Convolution</h3><h2 id="循环神经网络（RNN-Recurrent-Neural-Networks）"><a href="#循环神经网络（RNN-Recurrent-Neural-Networks）" class="headerlink" title="循环神经网络（RNN, Recurrent Neural Networks）"></a>循环神经网络（RNN, Recurrent Neural Networks）</h2><h2 id="长短期记忆网络（LSTM-Long-Short-Term-Memorys）"><a href="#长短期记忆网络（LSTM-Long-Short-Term-Memorys）" class="headerlink" title="长短期记忆网络（LSTM, Long Short-Term Memorys）"></a>长短期记忆网络（LSTM, Long Short-Term Memorys）</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.bilibili.com/video/BV1Lb411b7BS?from=search&seid=17888903676501609442" target="_blank" rel="noopener">B站-李宏毅讲解卷积神经网络（带字幕</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>笔记</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFT 板子</title>
    <link href="/2020/05/31/200601_FFT/"/>
    <url>/2020/05/31/200601_FFT/</url>
    
    <content type="html"><![CDATA[<h2 id="傅里叶变换-VS-离散傅里叶变换"><a href="#傅里叶变换-VS-离散傅里叶变换" class="headerlink" title="傅里叶变换 VS 离散傅里叶变换"></a>傅里叶变换 VS 离散傅里叶变换</h2>]]></content>
    
    
    <categories>
      
      <category>板子</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优化器</title>
    <link href="/2020/05/30/200530_optimizer/"/>
    <url>/2020/05/30/200530_optimizer/</url>
    
    <content type="html"><![CDATA[<p>深度学习中的优化算法主要围绕梯度下降算法展开，其主要思想是：选取一定的训练样本，按照一定的步长（学习率）沿着梯度的方向调整更新参数，优化模型的目标函数。</p><h2 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h2><p><strong>随机梯度下降法</strong>是每次使用一批数据进行梯度的计算，而非计算全部数据的梯度，因为如果每次计算全部数据的梯度，会导致运算量加大，运算时间变长，容易陷入局部最优解，而随机梯度下降可能每次不是朝着真正最小的方向，这样反而可以跳出局部的最优解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>优化器</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成式模型 VS 判别式模型</title>
    <link href="/2020/05/30/200530_Difference_between_generative_model_and_discriminative_model/"/>
    <url>/2020/05/30/200530_Difference_between_generative_model_and_discriminative_model/</url>
    
    <content type="html"><![CDATA[<h2 id="生成式模型-VS-判别式模型"><a href="#生成式模型-VS-判别式模型" class="headerlink" title="生成式模型 VS 判别式模型"></a>生成式模型 VS 判别式模型</h2><p><strong>Discriminative models</strong> learn the classification (hard or soft) boundary between classes. A discriminative model learns the conditional probability distribution p(y|x) - which you should read as “the probability of y given x”.</p><p><strong>Generative models</strong> model the distribution of individual classes. A generative model learns the joint probability distribution p(x,y)</p><p>生成模型是模拟这个结果是如何产生的,然后算出产生各个结果的概率。判别模型是发现各个结果之间的不同,不关心产生结果的过程。</p><p><img src="https://wx1.sbimg.cn/2020/05/30/diff_g_d.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="典型代表模型"><a href="#典型代表模型" class="headerlink" title="典型代表模型"></a>典型代表模型</h2><h3 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a>生成式模型</h3><ol><li>朴素贝叶斯</li><li>K紧邻（KNN）</li><li>混合高斯模型</li><li>隐马尔科夫模型（HMM）</li><li>贝叶斯网络</li><li>Sigmoid Belief Networks </li><li>马尔科夫随机场（Markov Random Fields）</li><li>深度信念网络（DBN）</li></ol><h3 id="判别式模型"><a href="#判别式模型" class="headerlink" title="判别式模型"></a>判别式模型</h3><ol><li>线性回归（Linear Regression）</li><li>逻辑斯蒂回归（Logistic Regression）</li><li>神经网络（NN）</li><li>支持向量机（SVM）</li><li>高斯过程（Gaussian Process）</li><li>条件随机场（CRF）</li><li>CART(Classification and Regression Tree)</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://papers.nips.cc/paper/2020-on-discriminative-vs-generative-classifiers-a-comparison-of-logistic-regression-and-naive-bayes.pdf" target="_blank" rel="noopener">On Discriminative vs. Generative classifiers: A comparison of logistic regression and naive Bayes</a></p><p>[2] <a href="https://stackoverflow.com/questions/879432/what-is-the-difference-between-a-generative-and-a-discriminative-algorithm/879591#879591" target="_blank" rel="noopener">The difference between a generative and a discriminative algorithm?</a></p><p>[3] <a href="https://www.cnblogs.com/yejintianming00/p/9378810.html" target="_blank" rel="noopener">判别式模型与生成式模型</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>笔记</tag>
      
      <tag>生成式模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2020/05/27/200527_first/"/>
    <url>/2020/05/27/200527_first/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到zyz的个人网站。这是我的第一篇博客。</p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
